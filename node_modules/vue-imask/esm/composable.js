import { isRef, ref, onMounted, onUnmounted, watch, readonly } from 'vue-demi';
import IMask from 'imask/esm/imask';

function useIMask(props, _temp) {
  let {
    emit,
    onAccept,
    onComplete
  } = _temp === void 0 ? {} : _temp;
  const _props = isRef(props) ? props : ref(props);
  const el = ref();
  const mask = ref();
  const masked = ref('');
  const unmasked = ref('');
  const typed = ref(null);
  const initialized = ref(false);
  let $el;
  let $lastAcceptedValue;
  let $lastAcceptedUnmaskedValue;
  let $lastAcceptedTypedValue;
  function _onAccept(event) {
    $lastAcceptedTypedValue = typed.value = mask.value.typedValue;
    $lastAcceptedUnmaskedValue = unmasked.value = mask.value.unmaskedValue;
    $lastAcceptedValue = masked.value = mask.value.value;
    if (emit) {
      emit('accept', masked.value, event);
      emit('accept:masked', masked.value, event);
      emit('accept:typed', typed.value, event);
      emit('accept:unmasked', unmasked.value, event);
    }
    if (onAccept) onAccept(event);
  }
  function _onComplete(event) {
    if (emit) {
      emit('complete', mask.value.value, event);
      emit('complete:masked', mask.value.value, event);
      emit('complete:typed', mask.value.typedValue, event);
      emit('complete:unmasked', mask.value.unmaskedValue, event);
    }
    if (onComplete) onComplete(event);
  }
  function _initMask() {
    $el = el.value;
    const $props = _props.value;
    if (!$el || !($props != null && $props.mask)) return;
    mask.value = IMask($el, $props).on('accept', _onAccept).on('complete', _onComplete);
    _onAccept();
    initialized.value = true;
  }
  function _destroyMask() {
    var _mask$value;
    if (!initialized.value) return;
    (_mask$value = mask.value) == null || _mask$value.destroy();
    mask.value = undefined;
  }
  onMounted(_initMask);
  onUnmounted(_destroyMask);
  watch(unmasked, () => {
    if (mask.value && initialized.value) {
      if ($lastAcceptedUnmaskedValue !== unmasked.value) mask.value.unmaskedValue = unmasked.value;
      $lastAcceptedUnmaskedValue = undefined;
    }
  });
  watch(masked, () => {
    if (mask.value && initialized.value) {
      if ($lastAcceptedValue !== masked.value) mask.value.value = masked.value;
      $lastAcceptedValue = undefined;
    }
  });
  watch(typed, () => {
    if (mask.value && initialized.value) {
      if ($lastAcceptedTypedValue !== typed.value) mask.value.typedValue = typed.value;
      $lastAcceptedTypedValue = undefined;
    }
  });
  watch([el, _props], () => {
    const $newEl = el.value;
    const $props = _props.value;
    if (!($props != null && $props.mask) || $newEl !== $el) _destroyMask();
    if ($newEl) {
      if (!mask.value) {
        _initMask();
      } else {
        mask.value.updateOptions($props);
      }
    }
  });
  return {
    el,
    mask: readonly(mask),
    masked,
    unmasked,
    typed
  };
}

export { useIMask as default };
